=== PROJECT STRUCTURE ===
./
├── collect.py
├── comm/
│   ├── initialize/
│   │   └── init.go
│   ├── middleware/
│   │   └── cros.go
│   ├── resp/
│   │   └── response.go
│   └── utils/
│       ├── container_list/
│       ├── lru_cache/
│       └── ticker/
├── go_project_code.txt
└── internal/
    └── claim/
        ├── api.go
        ├── dao.go
        ├── model/
        ├── router.go
        └── service.go

12 directories, 9 files



# ====== FILE: ./internal/claim/service.go ======

package claim

import (
	"claimask/src/internal/claim/model"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/bwmarrin/snowflake"
	"github.com/go-redis/redis"
)

// 定义包级别常量
const (
	maxClaimRetries  = 3
	maxClaimDuration = 5 * time.Second
	redisKeyPrizes   = "prizes"
	defaultNodeID    = 1
)

var (
	// 定义明确错误类型方便上层处理
	ErrNoPrizeLeft       = errors.New("no prize left")
	ErrExceedMaxAttempts = errors.New("exceed max attempts")
)

// OrderService 定义订单服务接口
type OrderService interface {
	ClaimPrize() error
	ClaimPrizeV2() error
	CreateOrder(address string) error
	QueryPrizes() (int, error)
	InitPrizes(quantity int)
}

// OrderServiceImpl 实现订单服务接口
type OrderServiceImpl struct {
	orderDAO OrderDAO
	redisCli *redis.Client
}

// NewOrderService 创建订单服务实例
func NewOrderService(orderDAO OrderDAO, rd *redis.Client) OrderService {
	return &OrderServiceImpl{
		orderDAO: orderDAO,
		redisCli: rd,
	}
}

// ClaimPrize 领取奖品（带事务重试机制）
// 实现原理：
// 1. 使用Redis Watch实现乐观锁控制
// 2. 采用有限次数的重试机制处理事务冲突
// 3. 设置总操作超时时间防止长时间阻塞
// 返回值：
//   - 成功时返回nil
//   - ErrNoPrizeLeft 奖品已领完
//   - ErrExceedMaxAttempts 超过最大尝试次数
func (s *OrderServiceImpl) ClaimPrize() error {
	startTime := time.Now()

	// 有限重试循环（避免无限重试导致系统阻塞）
	for retry := 0; retry < maxClaimRetries; retry++ {
		// 超时检查：总操作时间超过最大允许时长则立即终止
		if time.Since(startTime) > maxClaimDuration {
			return fmt.Errorf("operation timeout: %w", ErrExceedMaxAttempts)
		}

		// 开启Redis事务监控
		err := s.redisCli.Watch(func(tx *redis.Tx) error {
			// --- 事务开始 ---
			// 原子化操作步骤：
			// 1. 获取当前奖品数量
			// 2. 检查库存有效性
			// 3. 执行库存递减

			// 步骤1：获取当前奖品数量
			prizeCount, err := tx.Get(redisKeyPrizes).Int()
			if err != nil && err != redis.Nil { // 处理非"key不存在"的其他错误
				return fmt.Errorf("get prize count failed: %w", err)
			}

			// 步骤2：库存检查
			// 当库存<=0时返回特定错误，终止事务流程
			if prizeCount <= 0 {
				return ErrNoPrizeLeft
			}

			// 步骤3：执行库存递减操作
			// 使用管道提升事务执行效率（单次网络往返）
			_, err = tx.TxPipelined(func(pipe redis.Pipeliner) error {
				pipe.Decr(redisKeyPrizes)
				return nil
			})
			return err
		}, redisKeyPrizes) // 监控prizes键的变化

		// --- 事务处理结果分析 ---
		switch {
		case err == nil:
			// 成功情况：事务执行成功，直接返回
			return nil
		case errors.Is(err, ErrNoPrizeLeft):
			// 业务终止情况：明确无库存，直接向上返回错误
			return err
		case errors.Is(err, redis.TxFailedErr):
			// 事务冲突情况：记录日志并继续重试
			log.Printf("transaction conflict detected, retry count: %d/%d",
				retry+1, maxClaimRetries)
			continue
		default:
			// 不可恢复错误：包装错误信息后返回
			return fmt.Errorf("unexpected error: %w", err)
		}
	}

	// 重试耗尽：返回明确的尝试次数超限错误
	return ErrExceedMaxAttempts
}

// ClaimPrizeV2 领取奖品（利用 Redis 的单线程特性保证数据一致性）
// 实现原理：
// 1. 使用 Redis 的原子操作 DECR 保证库存递减的原子性。
// 2. 在 DECR 之前检查库存，避免超卖。
// 返回值：
//   - 成功时返回 nil
//   - ErrNoPrizeLeft 奖品已领完
func (s *OrderServiceImpl) ClaimPrizeV2() error {
	// 获取当前库存
	prizeCount, err := s.redisCli.Get(redisKeyPrizes).Int()
	if err != nil && err != redis.Nil { // 处理非"key不存在"的其他错误
		return fmt.Errorf("get prize count failed: %w", err)
	}

	// 检查库存
	if prizeCount <= 0 {
		return ErrNoPrizeLeft
	}

	// 执行库存递减操作（原子操作）
	newCount, err := s.redisCli.Decr(redisKeyPrizes).Result()
	if err != nil {
		return fmt.Errorf("decr prize count failed: %w", err)
	}
	// 再次检查库存，避免超卖
	if newCount < 0 {
		// 如果库存减为负数，回滚操作
		_, _ = s.redisCli.Incr(redisKeyPrizes).Result()
		return ErrNoPrizeLeft
	}
	return nil
}

// CreateOrder 创建订单
func (s *OrderServiceImpl) CreateOrder(address string) error {
	orderID, err := generateOrderID()
	if err != nil {
		return fmt.Errorf("generate order id failed: %w", err)
	}

	order := &model.Order{
		OrderID:    orderID,
		Address:    address,
		Json:       `{"key": "value"}`, // 建议改为配置项或参数传入
		InsertTime: time.Now(),
		UpdateTime: time.Now(),
	}

	if err := s.orderDAO.CreateOrder(order); err != nil {
		return fmt.Errorf("create order failed: %w", err)
	}
	return nil
}

// generateOrderID 生成分布式唯一ID
func generateOrderID() (uint64, error) {
	node, err := snowflake.NewNode(defaultNodeID)
	if err != nil {
		return 0, fmt.Errorf("create snowflake node failed: %w", err)
	}
	return uint64(node.Generate().Int64()), nil
}

// QueryPrizes 查询当前奖品数量
func (s *OrderServiceImpl) QueryPrizes() (int, error) {
	count, err := s.redisCli.Get(redisKeyPrizes).Int()
	if err != nil && err != redis.Nil {
		return 0, fmt.Errorf("query prizes failed: %w", err)
	}
	return count, nil
}

// InitPrizes 初始化奖品数量
func (s *OrderServiceImpl) InitPrizes(quantity int) {
	if _, err := s.redisCli.Set(redisKeyPrizes, quantity, 0).Result(); err != nil {
		log.Printf("init prizes failed: %v", err)
	}
}



# ====== FILE: ./internal/claim/api.go ======

package claim

import (
	"claimask/src/comm/resp"
	"claimask/src/internal/claim/model"
	"fmt"
	"strconv"

	"github.com/gin-gonic/gin"
)

// ClaimAPI 领取核心服务
type ClaimAPI struct {
	OrderService OrderService
}

func NewClaimAPI(orderService OrderService) *ClaimAPI {
	return &ClaimAPI{OrderService: orderService}
}

func (api *ClaimAPI) Claim(ctx *gin.Context) {
	var param model.ClaimParam
	if err := ctx.ShouldBindJSON(&param); err != nil {
		response.FailWithMessage(ctx, response.ERROR, "参数绑定失败: "+err.Error())
		return
	}

	// 领取奖品
	//if err := api.OrderService.ClaimPrize(); err != nil {
	//	response.FailWithMessage(ctx, response.ERROR, "奖品数量减少失败: "+err.Error())
	//	return
	//}

	if err := api.OrderService.ClaimPrizeV2(); err != nil {
		response.FailWithMessage(ctx, response.ERROR, "奖品数量减少失败: "+err.Error())
		return
	}

	// 创建订单
	if err := api.OrderService.CreateOrder(param.Address); err != nil {
		response.FailWithMessage(ctx, response.ERROR, "订单创建失败: "+err.Error())
		return
	}

	response.OkWithData(ctx, param)
}

func (api *ClaimAPI) Query(ctx *gin.Context) {
	prizes, err := api.OrderService.QueryPrizes()
	if err != nil {
		response.FailWithMessage(ctx, response.ERROR, "无法获取数量: "+err.Error())
		return
	}

	response.OkWithData(ctx, gin.H{"prizes": prizes})
}

func (api *ClaimAPI) Init(ctx *gin.Context) {
	quantityStr := ctx.Param("quantity")
	quantity, err := strconv.Atoi(quantityStr)
	if err != nil {
		response.FailWithMessage(ctx, response.ERROR, "无效的数量: "+err.Error())
		return
	}

	api.OrderService.InitPrizes(quantity)
	response.OkWithMessage(ctx, fmt.Sprintf("奖品数量已重置为 %d", quantity))
}



# ====== FILE: ./internal/claim/dao.go ======

package claim

import (
	"claimask/src/internal/claim/model"

	"github.com/jinzhu/gorm"
)

// OrderDAO 订单DAO接口
type OrderDAO interface {
	CreateOrder(order *model.Order) error
}

// OrderDAOImpl 订单DAO实现
type OrderDAOImpl struct {
	DB *gorm.DB
}

// NewOrderDAO 创建新的订单DAO实例
func NewOrderDAO(db *gorm.DB) OrderDAO {
	return &OrderDAOImpl{DB: db}
}

// CreateOrder 在数据库中创建订单
func (dao *OrderDAOImpl) CreateOrder(order *model.Order) error {
	return dao.DB.Table("order_id").Create(order).Error
}



# ====== FILE: ./internal/claim/router.go ======

package claim

import (
	"claimask/src/comm/middleware"
	"github.com/gin-gonic/gin"
)

func SetupRouter(api *ClaimAPI) *gin.Engine {
	r := gin.Default()

	// 使用跨域中间件
	r.Use(middleware.CorsMiddleware())

	// 定义名额领取接口
	r.POST("/claim", api.Claim)

	// 定义数量查询接口
	r.GET("/query", api.Query)

	// 新增接口 "/initialize" 实现奖品数量重置功能
	r.GET("/initialize/:quantity", api.Init)

	return r
}



# ====== FILE: ./internal/claim/model/po.go ======

package model

import (
	"time"
)

// ClaimParam defines the structure for claim request parameters
type ClaimParam struct {
	Address string `json:"address"`
}

// Order 定义订单结构体
type Order struct {
	ID         uint      `gorm:"primary_key"`
	OrderID    uint64    `gorm:"column:order_id"`
	Address    string    `gorm:"column:address"`
	Json       string    `gorm:"column:json"`
	InsertTime time.Time `gorm:"column:insert_time"`
	UpdateTime time.Time `gorm:"column:update_time"`
}



# ====== FILE: ./comm/middleware/cros.go ======

package middleware

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// CorsMiddleware 跨域中间件
func CorsMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {

		c.Header("Access-Control-Allow-Origin", c.GetHeader("Origin"))
		c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")
		c.Header("Access-Control-Allow-Headers", "Content-Type, LOGIN_USER, SGAME_ID")
		c.Header("Access-Control-Allow-Credentials", "true")

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(http.StatusNoContent)
			return
		}

		c.Next()
	}
}



# ====== FILE: ./comm/initialize/init.go ======

package initialize

import (
	"claimask/src/internal/claim/model"
	"log"

	"github.com/go-redis/redis"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

// InitDB 初始化数据库连接并迁移表结构
func InitDB() (*gorm.DB, error) {
	db, err := gorm.Open("mysql", "root:123@jiaru@tcp(127.0.0.1:3306)/faker?charset=utf8mb4&parseTime=True")
	if err != nil {
		return nil, err
	}

	// 自动迁移表结构
	db.AutoMigrate(&model.Order{})

	return db, nil
}

// InitRedis 初始化Redis连接
func InitRedis() *redis.Client {
	rd := redis.NewClient(&redis.Options{
		Addr:     "localhost:6379",
		Password: "", // no password set
		DB:       0,  // use default DB
	})

	// 在 Redis 中设置奖品数量
	rd.Set("prizes", 5, 0)

	return rd
}

// InitLogger 初始化日志
func InitLogger() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
}



# ====== FILE: ./comm/utils/lru_cache/leetcode/LRU.go ======

package main

import (
	"container/list"
	"fmt"
)

/*
*

	LRUCache 是一个LRU缓存，它支持以下操作：
	- Get 从缓存中获取一个元素
	- Put 向缓存中添加一个新元素或更新现有元素

*
*/
type LRUCache struct {

	// 缓存的容量
	capacity int

	// 哈希表，用于快速查找元素
	cache map[int]*list.Element

	// 双向链表，用于维护元素的LRU顺序
	queue *list.List
}

// entry 是双向链表节点的数据类型
type entry struct {
	key   int // 键
	value int // 值
}

// Constructor 初始化一个新的LRUCache
func Constructor(capacity int) LRUCache {
	return LRUCache{
		capacity: capacity,                    // 设置缓存容量
		cache:    make(map[int]*list.Element), // 初始化哈希表
		queue:    list.New(),                  // 初始化双向链表
	}
}

// Get 从缓存中获取一个元素的值
func (this *LRUCache) Get(key int) int {
	if elem, found := this.cache[key]; found { // 如果元素在缓存中
		this.queue.MoveToFront(elem)     // 将元素移动到双向链表的前端
		return elem.Value.(*entry).value // 返回元素的值
	}
	return -1 // 如果元素不在缓存中，返回-1
}

// Put 向缓存中添加一个新元素或更新现有元素
func (this *LRUCache) Put(key int, value int) {

	// 如果元素已经在缓存中
	if elem, found := this.cache[key]; found {
		this.queue.MoveToFront(elem)      // 将元素移动到双向链表的前端
		elem.Value.(*entry).value = value // 更新元素的值
		return
	}

	// 如果缓存已满
	if this.queue.Len() == this.capacity {
		oldest := this.queue.Back()                   // 获取双向链表的最后一个元素
		delete(this.cache, oldest.Value.(*entry).key) // 从哈希表中删除最老的元素
		this.queue.Remove(oldest)                     // 从双向链表中删除最老的元素
	}

	// 在双向链表的前端添加新元素
	// 在哈希表中添加新元素的引用
	elem := this.queue.PushFront(&entry{key, value})
	this.cache[key] = elem

}

// 测试用例
func main() {
	// 示例代码，演示如何使用LRUCache
	lru := Constructor(2)
	lru.Put(1, 1)
	lru.Put(2, 2)
	fmt.Println(lru.Get(1)) // 输出: 1
	lru.Put(3, 3)           // 逐出键2
	fmt.Println(lru.Get(2)) // 输出: -1 (未找到)
	lru.Put(4, 4)           // 逐出键1
	fmt.Println(lru.Get(1)) // 输出: -1 (未找到)
	fmt.Println(lru.Get(3)) // 输出: 3
	fmt.Println(lru.Get(4)) // 输出: 4
}



# ====== FILE: ./comm/utils/lru_cache/LRU_service/service.go ======

package main

import (
	"container/list"
	"fmt"
)

// CacheItem 是缓存中存储的数据类型。
type CacheItem struct {
	Key   string // 键，用于标识缓存项
	Value int    // 值，缓存项存储的数据
}

// LRUCache 是一个LRU（最近最少使用）缓存结构。
type LRUCache struct {
	capacity int                      // 缓存的容量
	elements map[string]*list.Element // 存储键和对应链表元素的映射
	list     *list.List               // 双向链表，用于存储缓存项
}

// NewLRUCache 初始化一个新的LRUCache。
func NewLRUCache(capacity int) *LRUCache {
	return &LRUCache{
		capacity: capacity,
		elements: make(map[string]*list.Element),
		list:     list.New(),
	}
}

// Get 从缓存中获取一个元素。
func (cache *LRUCache) Get(key string) (int, bool) {
	// 检查键是否存在
	if elem, found := cache.elements[key]; found {
		// 如果存在，将其移动到链表前端，表示最近使用过
		cache.list.MoveToFront(elem)
		// 返回找到的值和true
		return elem.Value.(*CacheItem).Value, true
	}
	// 如果不存在，返回0和false
	return 0, false
}

// Put 向缓存中添加一个新元素或更新现有元素。
func (cache *LRUCache) Put(key string, value int) {
	// 检查键是否已经存在
	if elem, found := cache.elements[key]; found {
		// 如果存在，更新值并移动到链表前端
		cache.list.MoveToFront(elem)
		elem.Value.(*CacheItem).Value = value
		return
	}

	// 如果缓存已满，移除最近最少使用的元素
	if cache.list.Len() == cache.capacity {
		oldest := cache.list.Back()
		cache.list.Remove(oldest)
		delete(cache.elements, oldest.Value.(*CacheItem).Key)
	}

	// 创建新的缓存项并添加到链表和映射中
	item := &CacheItem{Key: key, Value: value}
	elem := cache.list.PushFront(item)
	cache.elements[key] = elem
}

func main() {
	// 初始化一个容量为2的LRU缓存
	lru := NewLRUCache(2)

	// 添加元素
	lru.Put("one", 1)
	lru.Put("two", 2)
	// 获取元素并打印结果 lru.Get("one")
	fmt.Println(lru.Get("one")) // 应输出: 1, true

	// 添加新元素，导致键"two"被移除
	lru.Put("three", 3)
	// 尝试获取被移除的元素
	fmt.Println(lru.Get("two")) // 应输出: 0, false

	// 添加新元素，导致键"one"被移除
	lru.Put("four", 4)
	// 尝试获取被移除的元素
	fmt.Println(lru.Get("one")) // 应输出: 0, false
	// 获取存在的元素
	fmt.Println(lru.Get("three")) // 应输出: 3, true
	fmt.Println(lru.Get("four"))  // 应输出: 4, true
}



# ====== FILE: ./comm/utils/container_list/list.go ======

package main

import (
	"container/list"
	"fmt"
)

func main() {
	// 创建一个新的链表
	l := list.New()

	// 在链表尾部添加元素
	l.PushBack(1)
	l.PushBack(2)
	l.PushBack(3)

	// 在链表头部添加元素
	l.PushFront(0)

	// 遍历链表并打印元素
	for e := l.Front(); e != nil; e = e.Next() {
		fmt.Println(e.Value)
	}

	// // 删除链表头部元素
	// l.Remove(l.Front())

	// // 删除链表尾部元素
	// l.Remove(l.Back())

	// // 再次遍历链表并打印元素
	// for e := l.Front(); e != nil; e = e.Next() {
	// 	fmt.Println(e.Value)
	// }
}



# ====== FILE: ./comm/resp/response.go ======

// Package response 封装响应结构
package response

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

const (
	ERROR   = -1
	SUCCESS = 0
)

// Response 响应结构体
type Response struct {
	Code    int         `json:"code"`
	Data    interface{} `json:"data"`
	Msg     string      `json:"msg"`
	TraceID string      `json:"traceId"`
}

// Result trace Id
func Result(code int, data interface{}, msg string, c *gin.Context) {
	c.Set("ERROR_CODE", code)
	traceID := c.GetString("TRACKING_ID")
	// 开始时间
	c.JSON(http.StatusOK, Response{
		Code:    code,
		Data:    data,
		Msg:     msg,
		TraceID: traceID,
	})
}

// Ok result
func Ok(c *gin.Context) {
	Result(SUCCESS, map[string]interface{}{}, "操作成功", c)
}

// OkWithMessage result
func OkWithMessage(c *gin.Context, message string) {
	Result(SUCCESS, map[string]interface{}{}, message, c)
}

// OkWithData result
func OkWithData(c *gin.Context, data interface{}) {
	Result(SUCCESS, data, "操作成功", c)
}

// OkWithDetailed result
func OkWithDetailed(c *gin.Context, data interface{}, message string) {
	Result(SUCCESS, data, message, c)
}

// Fail result
func Fail(c *gin.Context, code int) {
	Result(code, map[string]interface{}{}, "操作失败", c)
}

// FailWithMessage result
func FailWithMessage(c *gin.Context, code int, message string) {
	Result(code, map[string]interface{}{}, message, c)
}


